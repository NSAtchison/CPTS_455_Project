import { app, BrowserWindow, ipcMain, dialog } from "electron";
import { createServer } from "http";
import { Server } from "socket.io";
import { startLANDiscovery } from "./lanDiscovery";
import { randomUUID } from "crypto";
import path from 'path';
import fs from 'fs';
import { io as ClientIO, Socket } from "socket.io-client"; // ✅ Added for peer connections
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

export const INSTANCE_ID = randomUUID(); // Each app instance has a unique ID
const PORT = 5001;

// ✅ Track discovered and connected peers
const discoveredPeers: { id: string; ip: string }[] = [];
const connectedPeers = new Map<string, Socket>();
const seenMessages = new Set<string>();

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
// eslint-disable-next-line unicorn/prefer-module
if (require("electron-squirrel-startup")) {
  app.quit();
}

ipcMain.handle("get-instance-id", () => INSTANCE_ID);

ipcMain.handle('open-file-dialog', async () => {
  const result = await dialog.showOpenDialog({ properties: ['openFile'] });
  return result.filePaths;
});

ipcMain.handle('read-file', async (_, filePath: string) => {
  const fs = await import('fs/promises');
  const buffer = await fs.readFile(filePath);
  console.log(buffer.toString('base64'))
  return buffer.toString('base64');
});

const getAppDataPath = () => {
  return app.getPath('userData');
};

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  mainWindow.removeMenu();

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  // mainWindow.webContents.openDevTools();

  mainWindow.webContents.once("did-finish-load", () => {
    mainWindow.webContents.send("set-instance-id", INSTANCE_ID);
  });

  const httpServer = createServer();
  const io = new Server(httpServer, {
    cors: { origin: "*" },
  });

  io.on("connection", (socket) => {
    console.log("New Socket.IO connection:", socket.id);

    socket.on("chat-message", async (message) => {

      // Deduplicate
      if (seenMessages.has(message.messageID)) return;
      seenMessages.add(message.messageID);

      console.log("Server received message:", message);

      // If it's a file, save it here too.
      if (message.isFile) {
        const fileName = message.text;
        const filePath = path.join(getAppDataPath(), fileName);

        const buffer = Buffer.from(message.fileData, "base64");
        await fs.promises.writeFile(filePath, buffer);

        console.log("Saved file to:", filePath);
      }

      // Rebroadcast to all clients
      io.emit("chat-message", message);

      // Rebroadcast to other outgoing peer connections
      for (const [peerIP, peerSocket] of connectedPeers) {
        peerSocket.emit("chat-message", message);
      }

      // Send to renderer
      mainWindow.webContents.send("chat-message", message);
    });
  });

  httpServer.listen(PORT, () => {
    console.log(`Socket.IO server listening on port ${PORT}`);
  });

  ipcMain.on("send-chat", (_, message) => {
    if (seenMessages.has(message.messageID)) return;
    seenMessages.add(message.messageID)
    io.emit("chat-message", message);

    // Send to any outbound peer connections
    for (const socket of connectedPeers.values()) {
      socket.emit("chat-message", message);
    }
  });

  startLANDiscovery(mainWindow, PORT, INSTANCE_ID);

  ipcMain.on("peer-found", (_, peer) => {
    const exists = discoveredPeers.some((p) => p.id === peer.id);
    if(!exists) {
      discoveredPeers.push(peer);
      console.log("Added peer:", peer);
      mainWindow.webContents.send("peer-list-updated", discoveredPeers);
    }
  });

  ipcMain.on("connect-to-peer", (_, ip: string) => {
    // If peer is already connected, don't connect again
    if (connectedPeers.has(ip)) return;
    
    console.log("Connecting to peer Socket.IO server:", ip);

    const socket: Socket = ClientIO(`http://${ip}:${PORT}`, {
      reconnectionAttempts: 3,
      timeout: 2000,
    });

    socket.on("connect", () => {
      console.log("Connected to peer:", ip);
      connectedPeers.set(ip, socket);
    });

    socket.on("chat-message", async (message) => {
      // 1️⃣ Deduplicate
      if (seenMessages.has(message.messageID)) return;
      seenMessages.add(message.messageID);

      console.log("Received message from peer:", message);

      if (message.isFile) {
        const fileName = message.text;
        const filePath = path.join(getAppDataPath(), fileName);

        // Convert base64 -> Buffer
        const buffer = Buffer.from(message.fileData, "base64");

        await fs.promises.writeFile(filePath, buffer);

        console.log("Saved file to:", filePath);
      }

      io.emit("chat-message", message);

      for (const [peerIP, peerSocket] of connectedPeers) {
        if (peerSocket !== socket) {
          peerSocket.emit("chat-message", message);
        }
      }

      mainWindow.webContents.send("chat-message", message);
    });

    socket.on("disconnect", () => {
      console.log("Disconnected from peer:", ip);
      connectedPeers.delete(ip);
    });

  })
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
