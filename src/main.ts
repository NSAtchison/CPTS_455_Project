import { app, BrowserWindow, ipcMain, dialog, shell } from "electron";
import { createServer } from "http";
import { Server } from "socket.io";
import { startLANDiscovery } from "./lanDiscovery";
import { randomUUID } from "crypto";
import path from "path";
import fs from "fs";
import { io as ClientIO, Socket } from "socket.io-client"; // ✅ Added for peer connections
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

export const INSTANCE_ID = randomUUID(); // Each app instance has a unique ID
const PORT = 5001;

// ✅ Track discovered and connected peers
const discoveredPeers: { id: string; ip: string }[] = [];
const connectedPeers = new Map<string, Socket>();
const seenMessages = new Set<string>();

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
// eslint-disable-next-line unicorn/prefer-module
if (require("electron-squirrel-startup")) {
  app.quit();
}

ipcMain.handle("get-instance-id", () => INSTANCE_ID);

ipcMain.handle("open-file-dialog", async () => {
  const result = await dialog.showOpenDialog({ properties: ["openFile"] });
  return result.filePaths;
});

ipcMain.handle("read-file", async (_, filePath: string) => {
  const fs = await import("fs/promises");
  const stat = await fs.stat(filePath);

  // Limit the maximum size file sent between users
  const MAX_FILE_SIZE = 20 * 1024 * 1024;

  if(stat.size > MAX_FILE_SIZE) {
    return { ok: false, error: "FILE_TOO_LARGE", size: stat.size, max: MAX_FILE_SIZE}
  }
  
  const buffer = await fs.readFile(filePath);
  const base64 = buffer.toString("base64");
  return { ok: true, data: base64 };
});

const getAppDataPath = () => {
  return app.getPath("userData");
};

ipcMain.handle("open-file", async (_, fileName: string) => {
  const filePath = path.join(getAppDataPath(), fileName);
  await shell.openPath(filePath);
});

ipcMain.handle("export-metrics", async (_, metrics) => {
  const { filePath, canceled } = await dialog.showSaveDialog({
    title: "Save Metrics",
    defaultPath: path.join(app.getPath("documents"), "lan-chat-metrics.json"),
    filters: [{ name: "JSON", extensions: ["json"] }],
  });

  if (canceled || !filePath) {
    return {
      ok: false,
      reason: "canceled",
    };
  }

  try {
    await fs.promises.writeFile(
      filePath,
      JSON.stringify(metrics, undefined, 2),
      "utf8",
    );
    console.log("Metrics exported to", filePath);
    return { ok: true, path: filePath };
  } catch (error) {
    console.error("Failed to export metrics:", error);
    return { ok: false, reason: "error" };
  }
});

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  mainWindow.removeMenu();

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  // mainWindow.webContents.openDevTools();

  mainWindow.webContents.once("did-finish-load", () => {
    mainWindow.webContents.send("set-instance-id", INSTANCE_ID);
  });

  const httpServer = createServer();
  const io = new Server(httpServer, {
    cors: { origin: "*" },
    maxHttpBufferSize: 20 * 1024 * 1024,
  });

  io.on("connection", (socket) => {
    console.log("New Socket.IO connection:", socket.id);

    socket.on("chat-message", async (message) => {
      if (seenMessages.has(message.messageID)) return;
      seenMessages.add(message.messageID);

      console.log("Message received:", message);

      // If this is a file message, save the file locally as well
      if (message.isFile && message.fileData) {
        try {
          const filePath = path.join(getAppDataPath(), message.text);
          const buffer = Buffer.from(message.fileData, "base64");
          await fs.promises.writeFile(filePath, buffer);
          console.log("Saved inbound file to:", filePath);
        } catch (error) {
          console.error("Failed to save inbound file:", error);
        }
      }

      // Broadcast to all others
      io.emit("chat-message", message);
      // Send to Renderer
      mainWindow.webContents.send("chat-message", message);
    });
  });

  httpServer.listen(PORT, () => {
    console.log(`Socket.IO server listening on port ${PORT}`);
  });

  ipcMain.on("send-chat", async (_, message) => {
    if (seenMessages.has(message.messageID)) return;
    seenMessages.add(message.messageID);

    // If this message contains file data, save it locally so it can be opened by filename
    if (message.isFile && message.fileData) {
      try {
        const filePath = path.join(getAppDataPath(), message.text);
        const buffer = Buffer.from(message.fileData, "base64");
        await fs.promises.writeFile(filePath, buffer);
        console.log("Saved local file to:", filePath);
      } catch (error) {
        console.error("Failed to save local file:", error);
      }
    }

    io.emit("chat-message", message);

    // Send to any outbound peer connections
    for (const socket of connectedPeers.values()) {
      socket.emit("chat-message", message);
    }
  });

  startLANDiscovery(mainWindow, PORT, INSTANCE_ID);

  ipcMain.on("peer-found", (_, peer) => {
    const exists = discoveredPeers.some((p) => p.id === peer.id);
    if (!exists) {
      discoveredPeers.push(peer);
      console.log("Added peer:", peer);
      mainWindow.webContents.send("peer-list-updated", discoveredPeers);
    }
  });

  ipcMain.on("connect-to-peer", (_, ip: string) => {
    // If peer is already connected, don't connect again
    if (connectedPeers.has(ip)) return;

    console.log("Connecting to peer Socket.IO server:", ip);

    const socket: Socket = ClientIO(`http://${ip}:${PORT}`, {
      reconnectionAttempts: 3,
      timeout: 2000,
    });

    socket.on("connect", () => {
      console.log("Connected to peer:", ip);
      connectedPeers.set(ip, socket);
    });

    socket.on("chat-message", async (message) => {
      if (message.isFile) {
        console.log("Received message from peer:", message);
        // Save file if message contains it.
        const fileName = message.text;
        console.log("file name:", fileName);
        const filePath = path.join(getAppDataPath(), fileName);

        if (message.fileData) {
          const buffer = Buffer.from(message.fileData, "base64");
          await fs.promises.writeFile(filePath, buffer);
          console.log("Saved file to:", filePath);
        } else {
          console.warn("Received file message without fileData for:", fileName);
        }
      } else {
        console.log("Received message from peer:", message);
      }
      mainWindow.webContents.send("chat-message", message);
    });

    socket.on("disconnect", () => {
      console.log("Disconnected from peer:", ip);
      connectedPeers.delete(ip);
    });
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
