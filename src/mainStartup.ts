import { ipcMethodHandlers } from "./ipcMethods";
import {
    app,
    ipcMain,
    session,
    BrowserWindow,
    Menu,
    nativeImage,
    Tray,
    shell,
} from "electron";
import { getEntries } from "./typescriptHelpers";
import { routes } from "../imports/api/constants";
import path from "path";
import { assetPath, createWindow, getAsset } from "./mainConstants"
import { ipcEmitAll } from "./ipcListeners";
import { ipcListenerKeys } from "./ipcPreloadHelpers";

// This is the webpack entry point. It is what starts everything.
// This runs in the main process.
process.title = "Electron Template (Change Me)";

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production)
// Main Menu Options
const isMac = process.platform === "darwin";
const menuTemplate: Parameters<typeof Electron.Menu.buildFromTemplate>[0] = [
    { role: "appMenu" },
    {
        label: "Test",
        submenu: [
            isMac ? { role: "close" } : { role: "quit" },
            {
                label: "Trigger IPC Listeners",
                click: () => ipcEmitAll(ipcListenerKeys.testListener, "From Main"),
            },
        ],
    },
    { role: "editMenu" },
    { role: "viewMenu" },
    { role: "windowMenu"},
    {
        role: "help",
        submenu: [
            {
                label: "Learn More",
                click: async () => {
                    await shell.openExternal("https://electronjs.org");
                },
            },
        ],
    },
];
const menu = Menu.buildFromTemplate(menuTemplate);
Menu.setApplicationMenu(menu);
let tray: Tray | undefined = undefined;
// Tray Icon
app.whenReady().then(() => {
    tray?.destroy();
    const icon = nativeImage
        .createFromPath(path.join(assetPath, "./icons/icon.png"))
        .resize({ height: 20 });
    tray = new Tray(icon);

    const contextMenu = Menu.buildFromTemplate([
        {
            label: "New Window",
            click: () => createWindow(routes.mainPage, { title: "Main Window"}),
        },
        {
            role: "quit",
        },
    ]);

    tray.setToolTip("Electron Template" + app.getVersion());
    tray.setContextMenu(contextMenu);
    // Work on right or left click
    tray.on("click", () => {
        tray?.popUpContextMenu();
    });
    return tray;
});

/////////////////////////////////
// Startup/quit event handlers //
/////////////////////////////////

app.on("window-all-closed", (event: { preventDefault: () => void}) => {
    // Don't shut down when all windows are closed
    event.preventDefault();
});

app.on("activate", async () => {
    // On OS X it's common to re-create a window in teh app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow(routes.mainPage, { title: "Main Page"});
    }
});

// If we see a second instance starting ( and we are the first instance)
app.on("second-instance", async () => {
    /// Someone tried to run a second instance, we should focus our windows or open a new one
    if (BrowserWindow.getAllWindows().length === 0) {
        await createWindow(routes.mainPage, { title: "Main Page" });
    }
    for (const win of BrowserWindow.getAllWindows()) {
        if (win.isMinimized()) win.restore();
        win.focus();
    }
});;

// This handles the listeners defined in ipcMethodHandlers, Don't touch this unless you know what you are doing.
const registerIpcMethods = async () => {
    getEntries(ipcMethodHandlers).map(([channel, handler]) => 
        ipcMain.handle(channel, handler),
    );
    console.log("Server successfully registered methods");
};

// Protocol to redirect static file references to the webpack packaged files
// This needs to be done after app is ready
const registerAssetProtocol = () =>
    session.defaultSession.protocol.registerFileProtocol(
        "asset",
        (request, callback) => {
            const fileUrl = request.url.replace("asset://", "");
            const filePath = path.join(assetPath, fileUrl);
            callback(filePath);
        },
    );

// This method will be called when Electron has finished
// initialization and is ready to create brwoser windows.
// Some APIs can only be used after this event occurs.
const createSplash = async () => {
    const splash = new BrowserWindow({
        width: 810,
        height: 610,
        show: true,
        transparent: true,
        frame: false,
        focusable: true,
    });
    await splash.loadFile(getAsset("./splash.html"));
    splash.setIgnoreMouseEvents(true);
    splash.focus();
    return splash;
};

(async () => {
    ////////////////////////////////////////////////////////////
    // Don't change this part unless you know what you're doing
    // It's all the preload registrations to make methods work
    ////////////////////////////////////////////////////////////
    await app.whenReady();
    registerAssetProtocol();
    const splash = await createSplash();
    await registerIpcMethods();
    console.log("Completed All Startup Registrations");

    ///////////////////////////////
    // Put your startup logic here
    ///////////////////////////////

    ////////////////////////////////////////////////////////////
    // Then show your main window and destroy the splash screen
    ////////////////////////////////////////////////////////////
    const main = createWindow(routes.mainPage, { title: "Main Window"});
    main.on("ready-to-show", () => {
        splash.destroy();
        main.focus();
    });
})();

/////////////////
// Quit Handlers
/////////////////
app.on("will-quit", async () => {
    console.log("Before quit called");
});